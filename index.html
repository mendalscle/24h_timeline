<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>1日の時間割タイムライン</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
  <style>
    body { font-family: sans-serif; padding: 10px; }
    #timeline { border: 1px solid #ccc; }
    /* 日付ラベル（曜日・月など）を非表示にする */
    .vis-time-axis .vis-text.vis-major {
      display: none !important;
    }

    /* タイムラインコンテナの幅制限を解除 */
    #timeline {
      border: 1px solid #ccc;
      /* width: 100% !important; */
    }

    /* 1時間あたりの最小幅を60pxに固定 */
    .vis-time-axis .vis-grid.vis-minor {
      min-width: 60px !important;
    }

    .vis-time-axis .vis-text.vis-minor {
      min-width: 60px !important;
    }

    /* アイテム上の線と丸を非表示にする */
    .vis-item .vis-item-overflow {
      overflow: hidden;
    }
    .vis-item .vis-item-content {
      position: relative;
    }
    .vis-item .vis-onUpdateTime-tooltip,
    .vis-item .vis-drag-center {
      display: none !important;
    }
    .vis-item.vis-range .vis-item-content::before,
    .vis-item.vis-range .vis-item-content::after {
      display: none !important;
    }
    
    /* アイテム縦幅を統一 */
    .vis-item {
      height: 30px !important;
      min-height: 30px !important;
    }
    .vis-item .vis-item-content {
      height: 30px !important;
      line-height: 30px !important;
      padding: 0 8px !important;
      box-sizing: border-box !important;
    }

    .vis-item .vis-delete {
      right: -28px;
    }


    /* テキストボックス追加フォーム */
    .add-item-box {
      margin-top: 15px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .add-item-box h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .input-row input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
      min-width: 200px;
    }
    .input-row button {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }
    .input-row button:hover:not(:disabled) {
      background: #218838;
    }
    .input-row button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .input-row button.cancel {
      background: #dc3545;
    }
    .input-row button.cancel:hover:not(:disabled) {
      background: #c82333;
    }

    /* 現在時刻ラインのドラッグを無効化 */
    .vis-custom-time.currentTime {
      pointer-events: none !important;
      cursor: default !important;
      z-index: 1 !important;
    }

  </style>
</head>
<body>
  <h2>1日の時間割（ドラッグで変更可能）</h2>
  <div id="timeline"></div>

  <!-- アイテム追加テキストボックス -->
  <div class="add-item-box">
    <h3>新しいアイテムを追加</h3>
    <div class="input-row">
      <input 
        type="text" 
        id="newItemInput" 
        placeholder="アイテム名を入力してください（タイムライン上をダブルクリックしてください）" 
        autocomplete="off"
        autocapitalize="off"
        autocorrect="off"
        spellcheck="false"
        disabled>
      <button id="addItemBtn" onclick="createNewItem()" disabled>追加</button>
      <button id="cancelBtn" onclick="cancelNewItem()" class="cancel" disabled>キャンセル</button>
    </div>
  </div>

  <script>
    // 新規アイテム作成用の変数
    let pendingItem = null;

    // テキストボックスでの新規アイテム作成機能
    function startNewItemCreation(clickTime) {
      // 開始時間を15分単位に調整
      const startTime = new Date(clickTime);
      const snapStart = Math.round(startTime.getTime() / (15 * 60 * 1000)) * (15 * 60 * 1000);
      const snappedStartTime = new Date(snapStart);
      
      // 開始時間から1時間後を終了時間に設定
      const endTime = new Date(snappedStartTime.getTime() + 60 * 60 * 1000);
      
      // 保留中のアイテム情報を保存
      pendingItem = {
        start: snappedStartTime.toISOString(),
        end: endTime.toISOString()
      };
      
      // モバイルでのフォーカス処理を改善
      setTimeout(() => {
        input.focus();
        if (input.setSelectionRange) {
          input.setSelectionRange(0, 0);
        }
      }, 300); // 遅延を追加

      // テキストボックスを有効化してフォーカス
      const input = document.getElementById('newItemInput');
      const addBtn = document.getElementById('addItemBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      
      input.disabled = false;
      input.placeholder = "アイテム名を入力してください";
      input.value = "";
      input.focus();
      
      addBtn.disabled = false;
      cancelBtn.disabled = false;
      
      console.log('新規アイテム作成開始:', pendingItem);
    }
    
    function createNewItem() {
      if (!pendingItem) return;
      
      const input = document.getElementById('newItemInput');
      const name = input.value.trim();
      
      if (!name) {
        alert('アイテム名を入力してください');
        input.focus();
        return;
      }
      
      // 新しいアイテムを作成
      const newItem = {
        id: Date.now(),
        content: name,
        start: pendingItem.start,
        end: pendingItem.end,
        editable: { updateTime: true, remove: true }
      };
      
      // タイムラインに追加
      items.add(newItem);
      saveItem(newItem);
      
      // リセット
      resetNewItemForm();
      
      console.log('新しいアイテムを作成しました:', newItem);
    }
    
    function cancelNewItem() {
      resetNewItemForm();
    }
    
    // アイテム編集用の変数
    let editingItemId = null;

    // アイテム編集を開始する関数
    function startItemEditing(itemId) {
      const item = items.get(itemId);
      if (!item) return;
      
      // 編集中のアイテムIDを保存
      editingItemId = itemId;
      
      // テキストボックスを編集モードに変更
      const input = document.getElementById('newItemInput');
      const addBtn = document.getElementById('addItemBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      
      input.disabled = false;
      input.placeholder = "アイテム名を変更してください";
      input.value = item.content;
      input.focus();
      input.select(); // 既存テキストを選択
      
      addBtn.textContent = "更新";
      addBtn.disabled = false;
      cancelBtn.disabled = false;
      
      // 新規作成データをクリア
      pendingItem = null;
      
      console.log('アイテム編集開始:', item);

      // モバイルでのフォーカス処理を改善
      setTimeout(() => {
        input.focus();
        input.select();
      }, 300);
    }

    // createNewItem関数を修正して編集にも対応
    function createNewItem() {
      const input = document.getElementById('newItemInput');
      const name = input.value.trim();
      
      if (!name) {
        alert('アイテム名を入力してください');
        input.focus();
        return;
      }
      
      if (editingItemId) {
        // 編集モードの場合
        items.update({ id: editingItemId, content: name });
        saveItem(items.get(editingItemId));
        console.log('アイテムを更新しました:', editingItemId);
      } else if (pendingItem) {
        // 新規作成モードの場合
        const newItem = {
          id: Date.now(),
          content: name,
          start: pendingItem.start,
          end: pendingItem.end,
          editable: true
        };
        
        items.add(newItem);
        saveItem(newItem);
        console.log('新しいアイテムを作成しました:', newItem);
      }
      
      // リセット
      resetNewItemForm();
    }

    function resetNewItemForm() {
      const input = document.getElementById('newItemInput');
      const addBtn = document.getElementById('addItemBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      
      input.disabled = true;
      input.placeholder = "アイテム名を入力してください（タイムライン上をダブルクリックしてください）";
      input.value = "";
      
      addBtn.textContent = "追加"; // ボタンテキストを元に戻す
      addBtn.disabled = true;
      cancelBtn.disabled = true;
      
      pendingItem = null;
      editingItemId = null; // 編集IDもクリア
    }
    
    

    // Enterキーで追加、Escapeキーでキャンセル
    document.getElementById('newItemInput').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !this.disabled) {
        // IMEによる変換中の場合は処理しない
        if (e.isComposing || e.keyCode === 229) {
          return;
        }
        createNewItem();
      } else if (e.key === 'Escape' && !this.disabled) {
        cancelNewItem();
      }
    });

    // 固定のダミー日付（どの日でもOK。時間だけ使う）
    const baseDate = "1970-01-01";

    // データベース初期化
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('timelineDB', 1);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('items')) {
            db.createObjectStore('items', { keyPath: 'id' });
          }
        };
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    }

    // 保存
    async function saveItem(item) {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        store.put(item);
        await new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
        console.log('アイテムを保存しました:', item);
      } catch (error) {
        console.error('保存に失敗しました:', error);
      }
    }

    // 削除
    async function deleteItem(id) {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        store.delete(id);
        await new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
        console.log('アイテムを削除しました:', id);
      } catch (error) {
        console.error('削除に失敗しました:', error);
      }
    }

    // 取得
    async function loadItems() {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readonly');
        const store = tx.objectStore('items');
        return new Promise((resolve, reject) => {
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('読み込みに失敗しました:', error);
        return [];
      }
    }

    // 初期ダミー
    const defaultItems = [
      { id: 1, content: '朝のルーチン', start: `${baseDate}T06:00:00`, end: `${baseDate}T07:00:00`, editable: true },
      { id: 2, content: '執筆',         start: `${baseDate}T09:00:00`, end: `${baseDate}T11:00:00`, editable: true },
      { id: 3, content: '昼休憩',       start: `${baseDate}T12:00:00`, end: `${baseDate}T13:00:00`, editable: true }
    ];

    // タイムラインのオプション
    const options = {
      editable: {
        add: false,  // ダブルクリックでの直接追加を無効化
        remove: true,
        updateTime: true,
        updateGroup: false,
        overrideItems: false
      },
      margin: { item: 10 },
      min: `${baseDate}T00:00:00`,
      max: `${baseDate}T24:00:00`,
        // 初期表示範囲（18時間程度に制限）
      start: `${baseDate}T06:00:00`,
      end: `${baseDate}T24:00:00`,
      orientation: 'top',
      stack: false,

      // ドラッグによる横スクロールを有効化
      moveable: true,

      // 時間軸の設定を追加
      timeAxis: {
        scale: 'hour',
        step: 1
      },

      snap: function (date, scale, step) {
        return Math.round(date / (15 * 60 * 1000)) * (15 * 60 * 1000); 
      },
      // 時間フォーマット設定
      format: {
        minorLabels: {
          hour: 'H時'
        },
        majorLabels: {
          hour: 'H時'
        }
      },
      onUpdate: function (item, callback) {
        callback(item);
        saveItem(item);
      },
      onRemove: function (item, callback) {
        callback(item);
        deleteItem(item.id);
      }
    };


    // 画面サイズに応じて表示範囲を動的調整
    function adjustTimelineRange() {
      const container = document.getElementById('timeline');
      const containerWidth = container.offsetWidth;
      
      // 1時間あたり60pxとして計算
      const minPixelsPerHour = 60;
      const maxDisplayableHours = Math.floor(containerWidth / minPixelsPerHour);
      
      if (maxDisplayableHours < 12) {
        // 表示可能時間数が12時間未満の場合、表示範囲を縮小
        const startHour = 6;
        const endHour = Math.min(startHour + maxDisplayableHours, 24);
        
        timeline.setWindow(
          `${baseDate}T${startHour.toString().padStart(2, '0')}:00:00`,
          `${baseDate}T${endHour.toString().padStart(2, '0')}:00:00`
        );
      }
    }

    // ウィンドウサイズ変更時に調整
    window.addEventListener('resize', adjustTimelineRange);

    // 初期化後に調整
    setTimeout(adjustTimelineRange, 200);

    // 現在時刻を表す縦線を追加する関数
    function addCurrentTimeLine() {
      const now = new Date();
      const currentTime = new Date(`${baseDate}T${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:00`);
      
      // カスタムタイムラインに現在時刻を設定
      timeline.addCustomTime(currentTime, 'currentTime');
      timeline.setCustomTimeTitle('現在時刻', 'currentTime');
    }

    // 現在時刻ラインのスタイルを設定
    function styleCurrentTimeLine() {
      setTimeout(() => {
        const currentTimeLine = document.querySelector('.vis-custom-time.currentTime');
        if (currentTimeLine) {
          currentTimeLine.style.backgroundColor = '#ff0000';
          currentTimeLine.style.width = '2px';
          currentTimeLine.style.zIndex = '10';
        }
        
        // 現在時刻のテキストも赤色にする
        const currentTimeText = document.querySelector('.vis-custom-time.currentTime .vis-custom-time-text');
        if (currentTimeText) {
          currentTimeText.style.color = '#ff0000';
          currentTimeText.style.fontWeight = 'bold';
        }
      }, 100);
    }



    const items = new vis.DataSet([]);

    // タイムライン作成
    const container = document.getElementById('timeline');
    const timeline = new vis.Timeline(container, items, options);

    // 初期化関数
    async function initializeApp() {
      try {
        const savedItems = await loadItems();
        console.log('IndexedDBから読み込んだデータ:', savedItems);
        
        if (savedItems && savedItems.length > 0) {
          // 保存されたデータがある場合は読み込み
          items.add(savedItems);
          console.log('保存されたデータを読み込みました');
        } else {
          // 保存されたデータがない場合はデフォルトデータを使用
          items.add(defaultItems);
          // デフォルトデータも保存する
          for (const item of defaultItems) {
            await saveItem(item);
          }
          console.log('デフォルトデータを設定しました');
        }
      } catch (error) {
        console.error('初期化に失敗しました:', error);
        // エラーの場合はデフォルトデータを使用
        items.add(defaultItems);
      }
      addCurrentTimeLine();
      styleCurrentTimeLine();
    }

    // アプリケーション初期化
    window.addEventListener('load', function() {
      console.log('ページ読み込み完了');
      console.log('vis:', typeof vis);
      initializeApp();

      // 1分ごとに現在時刻ラインを更新
      setInterval(() => {
        const now = new Date();
        const currentTime = new Date(`${baseDate}T${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:00`);
        timeline.setCustomTime(currentTime, 'currentTime');
      }, 60000); // 60秒ごと
    });

    // タッチデバイス用のダブルタップ処理を追加
    let lastTouchTime = 0;
    let touchCount = 0;

    timeline.on('click', function(props) {
      // タッチデバイスでのダブルタップ処理
      if ('ontouchstart' in window) {
        const currentTime = Date.now();
        touchCount++;
        
        if (touchCount === 1) {
          lastTouchTime = currentTime;
          // 300ms後にタッチカウントをリセット
          setTimeout(() => {
            touchCount = 0;
          }, 300);
        } else if (touchCount === 2 && (currentTime - lastTouchTime) < 300) {
          // ダブルタップを検出
          touchCount = 0;
          handleDoubleClick(props);
        }
      }
    });

    // ダブルクリック処理を共通化
    function handleDoubleClick(props) {
      if (props.item) {
        // 既存アイテムの編集開始
        startItemEditing(props.item);
      } else if (props.time) {
        // 空いている場所での新規アイテム作成開始
        startNewItemCreation(props.time);
      }
    }

    // 既存のdoubleClickイベントも共通関数を使用
    timeline.on('doubleClick', function (props) {
      handleDoubleClick(props);
    });

    // デバッグ用：現在のアイテム一覧を表示
    function showCurrentItems() {
      console.log('現在のアイテム一覧:', items.get());
    }

    // グローバルに公開（デバッグ用）
    window.showCurrentItems = showCurrentItems;
  </script>
</body>
</html>