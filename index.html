<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>1日の時間割タイムライン</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
  <style>
    body { font-family: sans-serif; padding: 10px; }
    #timeline { border: 1px solid #ccc; }
    /* 日付ラベル（曜日・月など）を非表示にする */
    .vis-time-axis .vis-text.vis-major {
      display: none !important;
    }

    /* タイムラインコンテナの幅制限を解除 */
    #timeline {
      border: 1px solid #ccc;
    }

    /* タイムライン全体の高さ固定 */
    #timeline {
        min-height: 70px !important;
        margin-bottom: 0px !important;
    }
    
    #timeline .vis-timeline {
        min-height: 70px !important;
    }
    
    #timeline .vis-content {
        min-height: 50px !important;
    }
    
    #timeline .vis-content .vis-itemset{
        min-height: 50px !important;
    }

    #timeline .vis-content .vis-group{
        min-height: 50px !important;
    }

    /* 1時間あたりの最小幅を60pxに固定 */
    .vis-time-axis .vis-grid.vis-minor {
      min-width: 60px;
    }

    .vis-time-axis .vis-text.vis-minor {
      min-width: 60px;
    }

    /* アイテム上の線と丸を非表示にする */
    .vis-item .vis-item-overflow {
      overflow: hidden;
    }
    .vis-item .vis-item-content {
      position: relative;
    }
    .vis-item .vis-onUpdateTime-tooltip,
    .vis-item .vis-drag-center {
      display: none !important;
    }
    .vis-item.vis-range .vis-item-content::before,
    .vis-item.vis-range .vis-item-content::after {
      display: none !important;
    }
    
    /* アイテム縦幅を統一 */
    .vis-item {
      height: 30px !important;
      min-height: 30px !important;
    }
    .vis-item .vis-item-content {
      height: 30px !important;
      line-height: 30px !important;
      padding: 0 8px !important;
      box-sizing: border-box !important;
    }

    .vis-item .vis-delete {
      right: -28px;
    }

    /* テキストボックス追加フォーム */
    .add-item-box {
      margin-top: 15px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .add-item-box h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .input-row input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
      min-width: 200px;
    }
    .input-row button {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }
    .input-row button:hover:not(:disabled) {
      background: #218838;
    }
    .input-row button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .input-row button.cancel {
      background: #dc3545;
    }
    .input-row button.cancel:hover:not(:disabled) {
      background: #c82333;
    }

    /* 現在時刻ラインのドラッグを無効化 */
    .vis-custom-time.currentTime {
      pointer-events: none !important;
      cursor: default !important;
      z-index: 1 !important;
    }

    /* モバイル対応（iPhone SE3: 375px基準） */
    @media screen and (max-width: 480px) {
      body {
        padding: 5px !important;
        font-size: 14px !important;
      }
      
      h2 {
        font-size: 18px !important;
        margin: 10px 0 !important;
        text-align: center !important;
      }
      
      /* タイムライン領域 */
      #timeline {
        border: 1px solid #ccc !important;
        margin-bottom: 15px !important;
      }
      
      /* アイテム追加フォーム */
      .add-item-box {
        padding: 12px !important;
        margin-top: 10px !important;
      }
      
      .add-item-box h3 {
        font-size: 16px !important;
        margin-bottom: 8px !important;
      }
      
      /* フォームを縦並びに変更 */
      .input-row {
        flex-direction: column !important;
        gap: 8px !important;
        align-items: stretch !important;
      }
      
      .input-row input {
        min-width: unset !important;
        width: 100% !important;
        padding: 12px !important;
        font-size: 16px !important;
        border-radius: 6px !important;
        box-sizing: border-box !important;
      }
      
      .input-row button {
        width: 100% !important;
        padding: 12px !important;
        font-size: 16px !important;
        border-radius: 6px !important;
        min-height: 44px !important;
      }
      
      /* タイムラインの時間表示を小さく */
      .vis-time-axis .vis-text {
        font-size: 12px !important;
      }
      
      /* アイテムのフォントサイズ調整（高い優先度） */
      .vis-item .vis-item-content {
        font-size: 12px !important;
        padding: 4px 6px !important;
        line-height: 1.2 !important;
        height: 28px !important;
      }
      
      /* アイテムのサイズもモバイル用に調整 */
      .vis-item {
        height: 28px !important;
        min-height: 28px !important;
      }
      
      /* 削除ボタンのサイズ調整 */
      .vis-item .vis-delete {
        width: 18px !important;
        height: 18px !important;
        font-size: 10px !important;
        right: -24px !important;
        top: -6px !important;
      }

      /* 現在時刻線を細く */
      .vis-custom-time.currentTime {
        width: 1px !important;
      }
      
      /* 1時間の最小幅をモバイル用に調整 */
      .vis-time-axis .vis-grid.vis-minor {
        min-width: 45px !important;
      }
      
      .vis-time-axis .vis-text.vis-minor {
        min-width: 45px !important;
      }

      /* タイムライン全体の高さ固定 */
      #timeline {
          min-height: 70px !important;
          margin-bottom: 0px !important;
      }
      
      #timeline .vis-timeline {
          min-height: 70px !important;
      }
      
      #timeline .vis-content {
          min-height: 50px !important;
      }
      
      #timeline .vis-content .vis-itemset{
          min-height: 50px !important;
      }

      #timeline .vis-content .vis-group{
          min-height: 50px !important;
      }
    }

    /* 極小画面対応（320px以下） */
    @media screen and (max-width: 320px) {
      #timeline {
        height: 150px !important;
      }
      
      .add-item-box {
        padding: 8px !important;
      }
      
      .input-row input,
      .input-row button {
        padding: 10px !important;
        font-size: 14px !important;
      }
      
      /* さらに小さい画面では目盛り幅を狭く */
      .vis-time-axis .vis-grid.vis-minor {
        min-width: 35px !important;
      }
      
      .vis-time-axis .vis-text.vis-minor {
        min-width: 35px !important;
      }

    }

  </style>
</head>
<body>
  <h2>1日の時間割（ドラッグで変更可能）</h2>
  <div id="timeline"></div>

  <!-- アイテム追加テキストボックス -->
  <div class="add-item-box">
    <h3>新しいアイテムを追加</h3>
    <div class="input-row">
      <input 
        type="text" 
        id="newItemInput" 
        placeholder="タイムライン上をダブルタップで新規作成" 
        autocomplete="off"
        autocapitalize="off"
        autocorrect="off"
        spellcheck="false"
        disabled>
      <button id="addItemBtn" onclick="createNewItem()" disabled>追加</button>
      <button id="cancelBtn" onclick="cancelNewItem()" class="cancel" disabled>キャンセル</button>
    </div>
  </div>

  <script>
    // 新規アイテム作成用の変数
    let pendingItem = null;
    // ズーム状態を管理する変数
    let isZooming = false;
    let zoomTimeout;
    // アイテム編集用の変数
    let editingItemId = null;
    // タッチデバイス用のダブルタップ処理を追加
    let lastTouchTime = 0;
    let touchCount = 0;

    // 定数定義
    const CONFIG = {
        BREAKPOINTS: {
            MOBILE: 480,
            TABLET: 1000
        },
        MIN_WIDTH: {
            MOBILE: 45,
            DESKTOP: 60
        },
        DELAYS: {
            FOCUS: 300,
            ZOOM_DETECT: 300
        },
        TIMELINE: {
            SNAP_INTERVAL: 15 * 60 * 1000, // 15分
            DEFAULT_DURATION: 60 * 60 * 1000, // 1時間
            UPDATE_INTERVAL: 60000 // 1分
        }
    };

    // キャッシュ用オブジェクト
    const DOM = {
        timeline: null,
        input: null,
        addBtn: null,
        cancelBtn: null
    };

    // XSS対策：HTMLエスケープ関数
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // DOM要素取得
    function cacheDOMElements() {
        DOM.timeline = document.getElementById('timeline');
        DOM.input = document.getElementById('newItemInput');
        DOM.addBtn = document.getElementById('addItemBtn');
        DOM.cancelBtn = document.getElementById('cancelBtn');
    }

    // テキストボックスでの新規アイテム作成機能
    function startNewItemCreation(clickTime) {
      // 開始時間を15分単位に調整
      const startTime = new Date(clickTime);
      const snapStart = Math.round(startTime.getTime() / CONFIG.TIMELINE.SNAP_INTERVAL) * CONFIG.TIMELINE.SNAP_INTERVAL;
      const snappedStartTime = new Date(snapStart);
      
      // 開始時間から1時間後を終了時間に設定
      const endTime = new Date(snappedStartTime.getTime() + CONFIG.TIMELINE.DEFAULT_DURATION);
      
      // 保留中のアイテム情報を保存
      pendingItem = {
        start: snappedStartTime.toISOString(),
        end: endTime.toISOString()
      };
      
      // モバイルでのフォーカス処理を改善
      setTimeout(() => {
        input.focus();
        if (input.setSelectionRange) {
          input.setSelectionRange(0, 0);
        }
      }, 300); // 遅延を追加

      // テキストボックスを有効化してフォーカス
      const input = DOM.input;
      const addBtn = DOM.addBtn;
      const cancelBtn = DOM.cancelBtn;
      
      input.disabled = false;
      input.placeholder = "アイテム名を入力してください";
      input.value = "";
      input.focus();
      
      addBtn.disabled = false;
      cancelBtn.disabled = false;
      
      console.log('新規アイテム作成開始:', pendingItem);
    }
    
    function cancelNewItem() {
      resetNewItemForm();
    }

    // アイテム編集を開始する関数
    function startItemEditing(itemId) {
      const item = items.get(itemId);
      if (!item) return;
      
      // 編集中のアイテムIDを保存
      editingItemId = itemId;
      
      // テキストボックスを編集モードに変更
      const input = DOM.input;
      const addBtn = DOM.addBtn;
      const cancelBtn = DOM.cancelBtn;
            
      input.disabled = false;
      input.placeholder = "アイテム名を変更してください";
      input.value = item.content;
      input.focus();
      input.select(); // 既存テキストを選択
      
      addBtn.textContent = "更新";
      addBtn.disabled = false;
      cancelBtn.disabled = false;
      
      // 新規作成データをクリア
      pendingItem = null;
      
      console.log('アイテム編集開始:', item);

      // モバイルでのフォーカス処理を改善
      setTimeout(() => {
        input.focus();
        input.select();
      }, 300);
    }

    // createNewItem関数を修正して編集にも対応
    function createNewItem() {
      const input = DOM.input;
      const name = input.value.trim();
      
      if (!name) {
        alert('アイテム名を入力してください');
        input.focus();
        return;
      }
      
      const safeName = escapeHtml(name); // エスケープ処理

      if (editingItemId) {
        // 編集モードの場合
        items.update({ id: editingItemId, content: safeName });
        saveItem(items.get(editingItemId));
        console.log('アイテムを更新しました:', editingItemId);
      } else if (pendingItem) {
        // 新規作成モードの場合
        const newItem = {
          id: Date.now(),
          content: safeName,
          start: pendingItem.start,
          end: pendingItem.end,
          editable: true
        };
        
        items.add(newItem);
        saveItem(newItem);
        console.log('新しいアイテムを作成しました:', newItem);
      }
      
      // リセット
      resetNewItemForm();
    }

    function resetNewItemForm() {
      const input = DOM.input;
      const addBtn = DOM.addBtn;
      const cancelBtn = DOM.cancelBtn;
      
      input.disabled = true;
      input.placeholder = "タイムライン上をダブルタップで新規作成";
      input.value = "";
      
      addBtn.textContent = "追加"; // ボタンテキストを元に戻す
      addBtn.disabled = true;
      cancelBtn.disabled = true;
      
      pendingItem = null;
      editingItemId = null; // 編集IDもクリア
    }
    
    

    // Enterキーで追加、Escapeキーでキャンセル
    document.getElementById('newItemInput').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !this.disabled) {
        // IMEによる変換中の場合は処理しない
        if (e.isComposing || e.keyCode === 229) {
          return;
        }
        createNewItem();
      } else if (e.key === 'Escape' && !this.disabled) {
        cancelNewItem();
      }
    });

    // 固定のダミー日付（どの日でもOK。時間だけ使う）
    const baseDate = "1970-01-01";

    // データベース初期化
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('timelineDB', 1);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('items')) {
            db.createObjectStore('items', { keyPath: 'id' });
          }
        };
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = (event) => reject(event.target.error);
      });
    }

    // 保存
    async function saveItem(item) {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        store.put(item);
        await new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
        console.log('アイテムを保存しました:', item);
      } catch (error) {
        console.error('保存に失敗しました:', error);
      }
    }

    // 削除
    async function deleteItem(id) {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readwrite');
        const store = tx.objectStore('items');
        store.delete(id);
        await new Promise((resolve, reject) => {
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error);
        });
        console.log('アイテムを削除しました:', id);
      } catch (error) {
        console.error('削除に失敗しました:', error);
      }
    }

    // 取得
    async function loadItems() {
      try {
        const db = await openDB();
        const tx = db.transaction('items', 'readonly');
        const store = tx.objectStore('items');
        return new Promise((resolve, reject) => {
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('読み込みに失敗しました:', error);
        return [];
      }
    }

    // 初期ダミー
    const defaultItems = [
      { id: 1, content: '朝のルーチン', start: `${baseDate}T06:00:00`, end: `${baseDate}T07:00:00`, editable: true },
      { id: 2, content: '執筆',         start: `${baseDate}T09:00:00`, end: `${baseDate}T11:00:00`, editable: true },
      { id: 3, content: '昼休憩',       start: `${baseDate}T12:00:00`, end: `${baseDate}T13:00:00`, editable: true }
    ];

    // タイムラインのオプション
    const options = {
      editable: {
        add: false,  // ダブルクリックでの直接追加を無効化
        remove: true,
        updateTime: true,
        updateGroup: false,
        overrideItems: false
      },
      margin: { item: 10 },
      min: `${baseDate}T00:00:00`,
      max: `${baseDate}T24:00:00`,
        // 初期表示範囲（18時間程度に制限）
      start: `${baseDate}T06:00:00`,
      end: `${baseDate}T24:00:00`,
      orientation: 'top',
      stack: false,

      // ドラッグによる横スクロールを有効化
      moveable: true,
      zoomable: true,
      
      zoomMin: CONFIG.TIMELINE.DEFAULT_DURATION, // 1時間を最小単位とする（ミリ秒単位）
      zoomMax: 24 * CONFIG.TIMELINE.DEFAULT_DURATION, // 24時間を最大単位とする

      // 時間軸の設定を追加
      timeAxis: {
        scale: 'hour',
        step: 1,
      },


      snap: function (date, scale, step) {
        return Math.round(date / CONFIG.TIMELINE.SNAP_INTERVAL) * CONFIG.TIMELINE.SNAP_INTERVAL; 
      },

      // 時間フォーマット設定
      format: {
        minorLabels: {
          hour: 'H時'
        },
        majorLabels: {
          hour: 'H時'
        }
      },
      
      onUpdate: function (item, callback) {
        console.log('onUpdate発火:', item); // デバッグ用
        callback(item); // これを先に呼ぶ
        saveItem(item); // その後保存
      },
      
      onMove: function(item, callback) {
        console.log('onMove発火:', item); // デバッグ用
        callback(item);
        saveItem(item);
      },
      
      onRemove: function (item, callback) {
        callback(item);
        deleteItem(item.id);
        
        // 削除されたアイテムが編集中だった場合、編集状態をリセット
        if (editingItemId === item.id) {
          console.log('編集中のアイテムが削除されたため、編集状態を終了します');
          resetNewItemForm();
        }
      },
    };
    
    // ウィンドウサイズ変更時に調整
    window.addEventListener('resize', adjustTimelineRange);

    // 初期化後に調整
    setTimeout(adjustTimelineRange, 200);

    // 現在時刻を表す縦線を追加する関数
    function addCurrentTimeLine() {
      const now = new Date();
      const currentTime = new Date(`${baseDate}T${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:00`);
      
      // カスタムタイムラインに現在時刻を設定
      timeline.addCustomTime(currentTime, 'currentTime');
      timeline.setCustomTimeTitle('現在時刻', 'currentTime');
    }

    // 現在時刻ラインのスタイルを設定
    function styleCurrentTimeLine() {
      setTimeout(() => {
        const currentTimeLine = document.querySelector('.vis-custom-time.currentTime');
        if (currentTimeLine) {
          currentTimeLine.style.backgroundColor = '#ff0000';
          currentTimeLine.style.width = '2px';
          currentTimeLine.style.zIndex = '10';
        }
        
        // 現在時刻のテキストも赤色にする
        const currentTimeText = document.querySelector('.vis-custom-time.currentTime .vis-custom-time-text');
        if (currentTimeText) {
          currentTimeText.style.color = '#ff0000';
          currentTimeText.style.fontWeight = 'bold';
        }
      }, 100);
    }



    const items = new vis.DataSet([]);

    // タイムライン作成
    const container = document.getElementById('timeline');
    const timeline = new vis.Timeline(container, items, options);

    // 初期化関数
    async function initializeApp() {
      try {
        const savedItems = await loadItems();
        console.log('IndexedDBから読み込んだデータ:', savedItems);
        
        if (savedItems && savedItems.length > 0) {
          // 保存されたデータがある場合は読み込み
          items.add(savedItems);
          console.log('保存されたデータを読み込みました');
        } else {
          // 保存されたデータがない場合はデフォルトデータを使用
          items.add(defaultItems);
          // デフォルトデータも保存する
          for (const item of defaultItems) {
            await saveItem(item);
          }
          console.log('デフォルトデータを設定しました');
        }
      } catch (error) {
        console.error('初期化に失敗しました:', error);
        // エラーの場合はデフォルトデータを使用
        items.add(defaultItems);
      }
      addCurrentTimeLine();
      styleCurrentTimeLine();
    }

    // アプリケーション初期化
    window.addEventListener('load', function() {
      console.log('ページ読み込み完了');
      console.log('vis:', typeof vis);
      initializeApp();
      
      // DOM要素をキャッシュ
      cacheDOMElements();

      // 1分ごとに現在時刻ラインを更新
      setInterval(() => {
        const now = new Date();
        const currentTime = new Date(`${baseDate}T${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:00`);
        timeline.setCustomTime(currentTime, 'currentTime');
      }, 60000); // 60秒ごと
    });

    // PC用のダブルクリックイベント
    timeline.on('doubleClick', function(props) {
      if (window.innerWidth > CONFIG.BREAKPOINTS.MOBILE) {
        handleDoubleClick(props);
      }
    });

    // ダブルクリック処理を共通化
    function handleDoubleClick(props) {
      if (props.item) {
        // 既存アイテムの編集開始
        startItemEditing(props.item);
      } else if (props.time) {
        // 空いている場所での新規アイテム作成開始
        startNewItemCreation(props.time);
      }
    }

    // クリック（モバイルダブルタップ）
    timeline.on('click', function(props) {
        if (window.innerWidth <= CONFIG.BREAKPOINTS.MOBILE) {
            handleMobileDoubleTap(props);
        }
    });

    // モバイルダブルタップ処理を分離
    function handleMobileDoubleTap(props) {
        const currentTime = Date.now();
        touchCount++;
        
        if (touchCount === 1) {
            lastTouchTime = currentTime;
            setTimeout(() => {
                touchCount = 0;
            }, CONFIG.DELAYS.ZOOM_DETECT);
        } else if (touchCount === 2 && 
                  (currentTime - lastTouchTime) < CONFIG.DELAYS.ZOOM_DETECT) {
            touchCount = 0;
            handleDoubleClick(props);
        }
    }

    // ズーム・スケール調整
    timeline.on('rangechange', handleRangeChange);

    // rangechange処理を分離
    function handleRangeChange(properties) {
        isZooming = true;
        clearTimeout(zoomTimeout);
        
        zoomTimeout = setTimeout(() => {
            isZooming = false;
            enforceMinWidth();
        }, CONFIG.DELAYS.ZOOM_DETECT);
        
        updateTimeAxisScale(properties);
    }

    // スケール更新処理を分離
    function updateTimeAxisScale(properties) {
        if (window.innerWidth <= CONFIG.BREAKPOINTS.TABLET) {
            const hoursDiff = (properties.end - properties.start) / (60 * 60 * 1000);
            
            let step = 1;
            if (hoursDiff > 16) step = 6;
            else if (hoursDiff > 8) step = 4;
            
            timeline.setOptions({
                timeAxis: { scale: 'hour', step }
            });
        } else {
            timeline.setOptions({
                timeAxis: { scale: 'hour', step: 1 }
            });
        }
    }

    function calculateDisplayRange(containerWidth, isMobile) {
        const now = new Date();
        const currentHour = now.getHours();
        const minPixelsPerHour = 60;
        const maxDisplayableHours = Math.floor(containerWidth / minPixelsPerHour);
        
        if (isMobile) {
            const halfHours = Math.floor(maxDisplayableHours / 2);
            let startHour = Math.max(0, currentHour - halfHours);
            let endHour = Math.min(24, currentHour + halfHours);
            
            if (startHour === 0) {
                endHour = Math.min(maxDisplayableHours, 24);
            }
            if (endHour === 24) {
                startHour = Math.max(24 - maxDisplayableHours, 0);
            }
            
            return { startHour, endHour };
        } else {
            if (maxDisplayableHours < 12) {
                return { startHour: 6, endHour: Math.min(18, 24) };
            }
            return null; // 調整不要
        }
    }

    function adjustTimelineRange() {
        const container = document.getElementById('timeline');
        const isMobile = window.innerWidth <= CONFIG.BREAKPOINTS.TABLET;
        const range = calculateDisplayRange(container.offsetWidth, isMobile);
        
        if (range) {
            timeline.setWindow(
                `${baseDate}T${range.startHour.toString().padStart(2, '0')}:00:00`,
                `${baseDate}T${range.endHour.toString().padStart(2, '0')}:00:00`
            );
        }
    }

    function enforceMinWidth() {
        // ズーム中は処理をスキップ
        if (isZooming) return;
        
        const minorElements = document.querySelectorAll('.vis-time-axis .vis-grid.vis-minor, .vis-time-axis .vis-text.vis-minor');
        const minWidth = window.innerWidth <= CONFIG.BREAKPOINTS.MOBILE ? CONFIG.MIN_WIDTH.MOBILE : CONFIG.MIN_WIDTH.DESKTOP;
        
        minorElements.forEach(element => {
            const currentWidth = parseFloat(element.style.width);
            if (currentWidth && currentWidth < minWidth) {
                element.style.width = minWidth + 'px';
            }
        });
    }

    // デバッグ用：現在のアイテム一覧を表示
    function showCurrentItems() {
      console.log('現在のアイテム一覧:', items.get());
    }

    // グローバルに公開（デバッグ用）
    window.showCurrentItems = showCurrentItems;
  </script>
</body>
</html>